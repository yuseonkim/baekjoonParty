
n = int(input())
# 1. 입력 받은 애들중에 최대길이를 반환
# 딕셔너리가 필요하겠음
# 1. if문을 통해서 key값이 있다면 + 그때의 문자열의 길이-인덱스 * 10
# 2. 없다면 키 값 추가 + 그때의 문자열의 길이 - 인덱스
# 어차피 그럼 (문자열의 길이 - 인덱스)*10을 곱해주면 되지 않을까?
word = [input() for _ in range(n)]


di = dict()
for i in range(n):
    for j in range(len(word[i])):
        if word[i][j] in di:
            di[word[i][j]] += 10**(len(word[i]) - j)
        else:
            di[word[i][j]] = 10**(len(word[i]) - j)
dic = sorted(di.items(), key = lambda x: -x[1])
num = 9
dicT = dict(dic)
for i in dicT:
    dicT[i] = str(num)
    num -= 1


for i in range(n):
    word[i] = list(word[i])
for i in range(n):
    for j in range(len(word[i])):
        word[i][j] = dicT[word[i][j]]

for i in range(n):
    word[i] = int(''.join(word[i]))
print(sum(word))

'''
해설 : 아이디어는 옛날에 생각해논거라서 푸는데 1시간? 정도 걸렸다!
dict는 좀 생소해서 이것저것 찾고 디버깅하느라 오래걸렸음
그렇지만! 골드 4를 푼게 뿌듯해서 주석으로 설명달아서 보존하고 백준팟에 커밋할 예정
물론 겨울방학이고 이제 다 끝나서 애초에 다른사람 코드를 보는 사람이 있나 싶긴하지만 그래서 적는거기도 함

-------------------------------------------------------------------------------------------
1. 가장 긴 문자열 중에서 가장 왼쪽에 있는 문자가 제일 큰 숫자를 가져야 한다.
2. 하지만 길이가 같은 동일선상에서는 그것보다 작은 위치에 또다른 숫자가 있는지 고려해줘야함
이 두 가지를 고려해야했다.
그래서 생각한 알고리즘 
- 알파벳 마다 들어가는 횟수(하지만 문자의 위치에 따라 가중치가 다르기 때문에 가중치 고려)를 담아줄 딕셔너리가 필요하다
- 그래서 key값을 알파벳으로 놓고 추가한다.
- 만약 dic에 키값이 있으면 추가하되, 10**(길이)를 곱해줘서 가중치를 고려해서 넣어준다.
- 이 후 value값에 따라 정렬할 수 있게 sorted(di.items(), ke~~)를 통해서 정렬
- 그래서 순차적으로 9부터 넣어줘야 하니까 num = 9에 넣고 각 키값에 값을 할당한다.
- 그리고나서 다시 word에 있는 문자들에 하나하나씩 접근해서 값을 넣고 int로 바꾸고
- 단어를 합친걸 출력!
'''
