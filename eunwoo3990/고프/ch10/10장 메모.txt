10장 프렌드와 연산자 중복

1. 프렌드 함수
1) 프렌드 : 외부의 클래스나 함수가 자신의 내부 데이터를 사용하도록 허가
하나의 클래스 프렌드로 지정 -> 그 클래스의 모든 멤버 함수는 내부 데이터 참조 가능
-프렌드 함수 선언은 클래스의 멤버가 아님 : public이나 private의 영향 받지x
-멤버 함수는 아니며 함수의 본체는 외부에서 따로 정의 됨
-프렌드 함수는 클래스 내부의 모든 멤버 변수사용가능, 호출가능

2) 예제
-부모클래스의 모든 멤버는 자식 클래스의 모든 함수에게 사용이 허가됨
-객체 비교하는 경우
-객체를 가지고 연산을 하는 경우

2. 연산자 중복
1) 형식
반환형 opertator연산자 (매개변수 목록) { 연산수행 }
- 클래스 멤버로 정의하는 것이 원책
- 프렌드 사용하면 클래스 외부에서 정의 가능
2) 멤버함수로 연산자 중복을 구현하는 방법 : 객체 지향의 원리에 더 충실한 방법
3) 전역함수로 구현 : 모든 피연산자들이 연산자 함수의 매개변수로 전달된다.

3. 피연산자의 타입이 다른 연산
- 전역함수로 구현이 쉬움
- 교환법칙 : 매개변수 위치가 교환된 연산자 함수

4. ==연산자 중복
5. <<연산자 중복 ostream& operator<<(ostream& os, const Vector& v) {...}
6. >>연산자 중복 istream& operator>>(istream& in, vector& v) {...} //Vector 매개변수 const 안됌!!
 - 반드시 ostream 또는 istream 참조자를 반환
7. 대입 연산자 중복(=)
 - 매개변수는 참조자
 - 참조자를 반환!!
 - 매개변수 변환해야 하므로 반드시 멤버함수!!
 - 얕은 대입 문제 
   : 대입 연산자를 다시 중복하여 정의하기 (기존의 공간을 반납하고 새로 공간을 할당받은 후 문자열을 복사)

8. 증가//감소 연산자 중복 : 포인터로 자기자신을 반환!!
 - 멤버함수 구현 : v.operator();
 - 전역함수 구현 : operator(v);
1) 후위 증가 후위감소 연산자
const Vector operator++(int) 형태

9. 인덱스 연산자[] 중복
10. 포인터 연산자의 중복  어려움 ㅜㅜ
11. 함수 호출 연산자 ()의 중복

12. 타입 변환 연산자의 중복
1) 변환 생성자 : 매개변수가 하나인 생성자를 사용하여 서로 다른 타입을 클래스 타입으로 변경가능
 - 반드시 매개변수가 하나
2) 변환 연산자 int value = (int) fvalue;
 - 형식
operator 데이터_타입() {...}

13. 연산자 중복 시에 유의할 점
 - 새로운 연산자 만들기x
 - 거의 모든 연산자 가능, :: .* . ?: 불가능
 - 클래스 타입의 피연산자를 반드시 가져야 함.
 - 우선순위나 결합법칙은 변경 불가
 - +를 중복, 일관성 위해 -,+=,-=도 중복하는 것이 좋음
 - 일반적으로 산술연산자, 관계연산자는 전역함수로, 대입연산자는 멤버함수로 정의
