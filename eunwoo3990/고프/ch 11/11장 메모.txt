11장 예외 처리와 형변환

1. 예외처리란
-버그와 예외

2.예외처리기
try
{
예외가 발생할 수도 있는 코드
if(예외조건)
    throw 예외;
}
catch(타입 매개 변수)
{
예외를 처리하는 코드
}

-예외가 발생 == 예외를 던진다
-예외가 발생하면 catch문으로 점프
 즉 throw 밑의 문장은 실행되지 않음
- catch 블록의 매개변수 
  : throw 문장에서 던진 값, 어떤 타입도 가능, 주로 예외에 대한 추가 정보
-타입이 일차하는 예외만 처리된다. 
 : 던진 예외와 잡는 예외의 타입이 같아야한다구
-모든 예외를 잡고 싶으면 catch(...)

3. 예외 전달
- 함수를 넘어서 전달 가능
- 모든 catch에서 받기 가능
- 함수안에서 예외 처리 가능 : 그냥 함수안에 catch
- 헤더에서 예외 명시
 : 함수 안에서 발생된 예외를 즉시 처리하지 않으려면 헤더의 정의 부분에 명시
int dividePizza(int s, int p) throw()        //예외를 던지지 않음
int dividePizza(int s, int p) throw(..)       //예외를 던진다. 타입은 지정하지 않음
int dividePizza(int s, int p) throw(int)    //int 타입의 예외를 던진다.
int dividePizza(int s, int p) throw(int, double)  //int또는 double 타입의 예외를 던진다
- 만약 예외가 처리되지 않으면 abort()함수가 호출되어 프로그램 종료

4. 다중 catch문장
- 하나의 try 블록에서는 여러 개의 throw 문장을 가질 수 있음
- 여러 타입의 값을 처리하려면 여러개의 catch문장 필요
- 이런 경우 구체적인 예외를 먼저, 일반적인 예외는 나중에

5. 자신의 예외 클래스를 작성하는 방법
 1)예외 클래스
예외에 대한 정보를 묶어서 클래스로 정의 -> 이 클래스의 객체를 던진다.
- 예외를 각 유형별로 분류, 정리 가능
throw NoPersonException(persons);
 2)상속관계에 있는 예외 클래스
- 매개변수를 부모 클래스의 참조자 타입으로 지정하면 자손 클래스의 객체들을
모두 잡을 수 있다.
- catch 블록에서는 자식 클래스의 잠조자를 더 위에 배치하는 것이 일반적!!

6. 형변환
- 형변환 연산자
static_cast     기본 타입의 변환이나 상속 관계에 있는 클래스 포인터를 변환할 때
dynamic_cas 상속관계에 있는 클래스포인터를 안전하게 변환할때 사용, 실행시간에 식별 가능

1) static_cast
 : 논리적으로 타당한 변환만을 수행 (기본 자료형 간의 변환 허용)
그러나 포인터의 타입 변경은 허용ㄴㄴ
다만 상속관계에 있는 클래스 포인터들은 변환 가능
(형식)
static_cast<타입> (대상)

2) dynamic_cast
 : 주로 상속 관계에 있는 클래스 포인터나 클래스 참조자를 변환
(형식)
dynamic_cast<타입> (포인터 또는 참조자)
- 자식을 부모 포인터로 가리키는 상향 형변환만 허용
- 클래스 포인터 간의 형변환을 검사할 수 있음
- 변환이 올바르면 변환된 타입을 반환, 그렇지 않으면 NULL
- 부모 클래스가 가상함수를 사용하고 있어야 함
- 다형 클래스 : 가상 함수를 가지는 클래스

7. 타입 정보
- typeid 연산자 사용하여 객체의 타입 식별 가능